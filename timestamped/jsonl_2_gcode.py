#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
bm_to_gcode.py â€” Bambu-Bus Movement Packet to G-code Converter

This script reads a .bm.jsonl file (generated by bm_parse_ts.py) and
reconstructs the G-code movement commands (G0/G1) from the raw packet data.

It serves as a validation tool to confirm the reverse-engineered packet format
by comparing its output to the original G-code file used for the capture.

Usage:
    python bm_to_gcode.py --infile your_capture.bm.jsonl --outfile reconstructed.gcode
"""

import argparse
import json
import struct
import sys
import os

def decode_movement_packet(payload_hex: str) -> str | None:
    """
    Decodes a single '3b33' motor movement packet payload into a G-code string.
    
    Args:
        payload_hex: The hexadecimal string of the packet's payload.

    Returns:
        A formatted G-code string (e.g., "G1 X10.00 Y10.00 F6000.0") or None if the
        packet is not a valid movement command.
    """
    if not payload_hex.startswith("3b33") or len(payload_hex) < 26:
        return None # Not a 13-byte movement command payload

    try:
        data = bytes.fromhex(payload_hex)
        
        # According to our analysis:
        # [0:2] = Header (3b33)
        # [2]   = Axis Bitmask
        # [3]   = Direction Flag
        # [4]   = Move Type Flag (G0/G1)
        # [5:9] = Distance (32-bit float, little-endian)
        # [9:13]= Velocity (32-bit float, little-endian)

        axis_mask = data[2]
        direction_flag = data[3]
        move_type_flag = data[4]
        
        # Unpack the 32-bit floating point numbers
        distance = struct.unpack('<f', data[5:9])[0]
        velocity_mms = struct.unpack('<f', data[9:13])[0]

        # Convert velocity from mm/s to mm/min for the F parameter
        feedrate = velocity_mms * 60

        # Determine the command type
        command = "G1" if move_type_flag == 0 else "G0"

        # Build the axis part of the command
        axes = []
        sign = "-" if direction_flag == 1 else ""
        
        if axis_mask & 0x01: # X-axis
            axes.append(f"X{sign}{distance:.3f}")
        if axis_mask & 0x02: # Y-axis
            axes.append(f"Y{sign}{distance:.3f}")
        if axis_mask & 0x04: # Z-axis
            axes.append(f"Z{sign}{distance:.3f}")
        if axis_mask & 0x08: # E-axis
            axes.append(f"E{sign}{distance:.3f}")
            
        if not axes:
            return None # No axis specified

        # Assemble the final G-code string
        # For G0 moves, the feedrate is often implicit, but we include it for clarity.
        return f"{command} {' '.join(axes)} F{feedrate:.1f}"

    except (struct.error, ValueError, IndexError):
        # Handle cases where the payload is malformed
        return None

def main():
    """Main execution function."""
    parser = argparse.ArgumentParser(description="Bambu-Bus JSONL to G-code Converter")
    parser.add_argument("--infile", required=True, help="Input .bm.jsonl file")
    parser.add_argument("--outfile", required=True, help="Output .gcode file")
    args = parser.parse_args()

    if not os.path.exists(args.infile):
        print(f"ERROR: Input file not found: {args.infile}", file=sys.stderr)
        sys.exit(1)

    print(f"Reading from: {args.infile}")
    print(f"Writing G-code to: {args.outfile}")

    reconstructed_count = 0
    with open(args.infile, 'r') as jsonl_file, open(args.outfile, 'w') as gcode_file:
        for line in jsonl_file:
            try:
                frame = json.loads(line)
                payload = frame.get("payload_hex")
                if payload:
                    gcode_command = decode_movement_packet(payload)
                    if gcode_command:
                        gcode_file.write(gcode_command + "\n")
                        reconstructed_count += 1
            except json.JSONDecodeError:
                print(f"Warning: Skipping malformed JSON line: {line.strip()}", file=sys.stderr)
                continue
    
    print(f"\nConversion complete. Reconstructed {reconstructed_count} G-code movement commands.")

if __name__ == "__main__":
    main()
